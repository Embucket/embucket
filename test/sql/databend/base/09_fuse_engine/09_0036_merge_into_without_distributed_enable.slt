exclude-from-coverage
statement ok
create or replace table t1(a int,b string, c string);

exclude-from-coverage
statement ok
create or replace table t2(a int,b string, c string);

exclude-from-coverage
statement ok
insert into t1 values(1,'b1','c1'),(2,'b2','c2');

exclude-from-coverage
statement ok
insert into t1 values(2,'b3','c3'),(3,'b4','c4');

exclude-from-coverage
query TTT
select * from t1 order by a,b,c;
----
1	b1	c1
2	b2	c2
2	b3	c3
3	b4	c4

exclude-from-coverage
statement ok
insert into t2 values(1,'b_5','c_5'),(3,'b_6','c_6');

exclude-from-coverage
statement ok
insert into t2 values(2,'b_7','c_7');

exclude-from-coverage
query TTT
select * from t2 order by a,b,c;
----
1	b_5	c_5
2	b_7	c_7
3	b_6	c_6

### test source alias
#statement error
#merge into t1 using (select * from t2 ) on t1.a = t2.a  when matched then update set t1.c = t2.c,t1.c = t2.c;
#----
#1005
#
## section I: basic test for match and unmatch
#
#statement error
#merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then update set t1.c = t2.c,t1.c = t2.c;
#----
#1006

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then update set t1.c = t2.c;

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5
2	b2	c_7
2	b3	c_7
3	b4	c_6

exclude-from-coverage
statement ok
insert into t2 values(4,'b_8','c_8');

exclude-from-coverage
query TTT
select * from t2 order by a,b,c;
----
1	b_5	c_5
2	b_7	c_7
3	b_6	c_6
4	b_8	c_8

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then update set t1.c = t2.c  when not matched then insert (a,b,c) values(t2.a,t2.b,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5
2	b2	c_7
2	b3	c_7
3	b4	c_6
4	b_8	c_8

exclude-from-coverage
statement ok
create or replace table t2(a int,b string, c string);

exclude-from-coverage
statement ok
insert into t2 values(1,'b_9','c_9');

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then update set t1.c = t2.c  when not matched then insert (a,b,c) values(t2.a,t2.b,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_9
2	b2	c_7
2	b3	c_7
3	b4	c_6
4	b_8	c_8

exclude-from-coverage
statement ok
delete from t2 where a = 1;

exclude-from-coverage
query TTT
select * from t2 order by a,b,c;
----
2	b_7	c_7
3	b_6	c_6
4	b_8	c_8

exclude-from-coverage
statement ok
insert into t2 values(5,'b_9','c_9');

exclude-from-coverage
query TTT
select * from t2 order by a,b,c;
----
2	b_7	c_7
3	b_6	c_6
4	b_8	c_8
5	b_9	c_9

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then delete;

query ITT
select * from t1 order by a,b,c;
----
1	b1	c_5

# section 2 multi clauses
exclude-from-coverage
statement ok
create or replace table t1(a int,b string, c string);

exclude-from-coverage
statement ok
create or replace table t2(a int,b string, c string);

exclude-from-coverage
statement ok
insert into t1 values(1,'b1','c_5');

exclude-from-coverage
statement ok
insert into t1 values(2,'b_1','c_1'),(3,'b_2','c_2');

exclude-from-coverage
statement ok
insert into t2 values(2,'b_7','c_7'),(3,'b_6','c_6');

exclude-from-coverage
statement ok
insert into t2 values(4,'b_8','c_8'),(5,'b_9','c_9');

exclude-from-coverage
query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5
2	b_1	c_1
3	b_2	c_2

#statement error
#merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then delete when matched then update set t1.c = t2.c when not matched and t2.c = 'c_8' then insert (a,b,c) values(t2.a,t2.b,t2.c);
#----
#1005

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched and t1.b = 'b_1' then delete when matched then update set t1.c = t2.c when not matched and t2.c = 'c_8' then insert (a,b,c) values(t2.a,t2.b,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5
3	b_2	c_6
4	b_8	c_8

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then delete when not matched and t2.c = 'c_9' then insert (a,b,c) values(t2.a,t2.b,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5
5	b_9	c_9

statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a when not matched and t2.c = 'c_8' then insert (a,b) values(t2.a,t2.b) when not matched and t2.c = 'c_7' then insert (a,c) values(t2.a,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5
2	NULL	c_7
4	b_8	NULL
5	b_9	c_9

exclude-from-coverage
statement ok
insert into t2 values(5,'b_10','c_10');

exclude-from-coverage
query TTT
select * from t2 order by a,b,c;
----
2	b_7	c_7
3	b_6	c_6
4	b_8	c_8
5	b_10	c_10
5	b_9	c_9

#statement error
#merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a when matched and t2.c = 'c_9' then update set t1.b = 'b_11' when matched and t2.c = 'c_10' then delete;
#----
#4001

## idempotent delete test
statement ok
merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a when matched then delete;

query TTT
select * from t1 order by a,b,c;
----
1	b1	c_5

### test star for merge into
#exclude-from-coverage
#statement ok
#create or replace table t1(a int,b string, c string);
#
#exclude-from-coverage
#statement ok
#create or replace table t2(a int,b string, c string);
#
#exclude-from-coverage
#statement ok
#insert into t1 values(1,'b1','c1'),(2,'b2','c2');
#
#exclude-from-coverage
#query TTT
#select * from t1 order by a,b,c;
#----
#1	b1	c1
#2	b2	c2
#
#exclude-from-coverage
#statement ok
#insert into t2 values(1,'b3','c3'),(3,'b4','c4');
#
#exclude-from-coverage
#query TTT
#select * from t2 order by a,b,c;
#----
#1	b3	c3
#3	b4	c4
#
### test insert columns mismatch
#statement error
#merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a when not matched then insert values(t2.a,t2.c);
#----
#1065
#
#statement ok
#merge into t1 using (select * from t2 ) as t2 on t1.a = t2.a  when matched then update *  when not matched then insert *;
#
#
#query TTT
#select * from t1 order by a,b,c;
#----
#1	b3	c3
#2	b2	c2
#3	b4	c4
#
### test multi same name for star
#statement error
#merge into t1 using (select a,b,c,a from t2 ) as t2 on t1.a = t2.a  when matched then update *;
#----
#1065
#
#statement error
#merge into t1 using (select a,b,c,a,b from t2 ) as t2 on t1.a = t2.a  when not matched then insert *;
#----
#1065

### stage file test
#exclude-from-coverage
#statement ok
#drop table if exists test_stage;
#
#exclude-from-coverage
#statement ok
#drop table if exists target_table;
#
#exclude-from-coverage
#statement ok
#create or replace table target_table(a int,b string,c string);
#
#exclude-from-coverage
#statement ok
#insert into target_table values(1,'a_1','b_1'),(2,'a_2','b_2');
#
#exclude-from-coverage
#query TTT
#select * from target_table order by a,b,c;
#----
#1	a_1	b_1
#2	a_2	b_2
#
#exclude-from-coverage
#statement ok
#create  or replace table test_stage(a int,b string,c string);
#
#exclude-from-coverage
#statement ok
#insert into test_stage values(1,'a1','b1'),(2,'a2','b2'),(3,'a3','b3');
#
#exclude-from-coverage
#query TTT
#select * from test_stage order by a,b,c;
#----
#1	a1	b1
#2	a2	b2
#3	a3	b3
#
#exclude-from-coverage
#statement ok
#drop stage if exists s5_merge_into;
#
#exclude-from-coverage
#statement ok
#drop stage if exists s4_merge_into;
#
#exclude-from-coverage
#statement ok
#create stage s5_merge_into FILE_FORMAT = (TYPE = CSV);
#
#exclude-from-coverage
#statement ok
#remove @s5_merge_into;
#
#exclude-from-coverage
#statement ok
#copy into @s5_merge_into from (select a,b,c from test_stage order by a,b,c);
#
#exclude-from-coverage
#query TTT
#select $1,$2,$3	from @s5_merge_into order by $1,$2,$3;
#----
#1	a1	b1
#2	a2	b2
#3	a3	b3
#
### test CSV
#statement ok
#merge into target_table using (select $1,$2,$3	from @s5_merge_into) as cdc on cast(cdc.$1 as int) = target_table.a when matched then delete when not matched then insert values(cdc.$1,cdc.$2,cdc.$3);
#
#query TTT
#select * from target_table order by a,b,c;
#----
#3	a3	b3
#
### test parquet
#exclude-from-coverage
#statement ok
#create or replace table target_table(a int,b string,c string);
#
#exclude-from-coverage
#query I
#select count(*) from target_table;
#----
#0
#
#exclude-from-coverage
#statement ok
#create stage s4_merge_into FILE_FORMAT = (TYPE = PARQUET);
#
#exclude-from-coverage
#statement ok
#remove @s4_merge_into;
#
#exclude-from-coverage
#statement ok
#copy into @s4_merge_into from (select a,b,c from test_stage order by a,b,c);
#
#exclude-from-coverage
#query TTT
#select a,b,c from @s4_merge_into order by a,b,c;
#----
#1	a1	b1
#2	a2	b2
#3	a3	b3
#
#exclude-from-coverage
#statement ok
#insert into target_table values(1,'a_1','b_1'),(2,'a_2','b_2');
#
#exclude-from-coverage
#query TTT
#select * from target_table order by a,b,c;
#----
#1	a_1	b_1
#2	a_2	b_2
#
#statement ok
#merge into target_table using (select a,b,c from @s4_merge_into) as cdc on cdc.a = target_table.a when matched then delete when not matched then insert values(cdc.a,cdc.b,cdc.c);
#
#query TTT
#select * from target_table order by a,b,c;
#----
#3	a3	b3

## NULL test, for join, if join_expr result is
## NULL, it will be treated as not matched.
exclude-from-coverage
statement ok
create or replace table t1(a int,b string, c string);

exclude-from-coverage
statement ok
create or replace table t2(a int,b string, c string);

exclude-from-coverage
statement ok
insert into t1 values(NULL,'b_1','c_1');

exclude-from-coverage
query TTT
select * from t1 order by a,b,c;
----
NULL	b_1	c_1

exclude-from-coverage
statement ok
insert into t2 values(1,'b_4','c_4'),(2,'b_2','c_2'),(NULL,'b_3','c_3');

exclude-from-coverage
query TTT
select * from t2 order by a,b,c;
----
1	b_4	c_4
2	b_2	c_2
NULL	b_3	c_3

statement ok
merge into t1 using (select * from t2) as t2 on t1.a = t2.a when matched then delete when not matched then insert (a,b,c) values(t2.a,t2.b,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	b_4	c_4
2	b_2	c_2
NULL	b_1	c_1
NULL	b_3	c_3

statement ok
merge into t1 using (select * from t2) as t2 on t1.a = t2.a when matched then delete;

query TTT
select * from t1 order by a,b,c;
----
NULL	b_1	c_1
NULL	b_3	c_3

exclude-from-coverage
statement ok
create or replace table t1(a int,b string, c string);

exclude-from-coverage
statement ok
create or replace table t2(a int,b string, c string);

## test target table alias
exclude-from-coverage
statement ok
insert into t2 values(1,'a1','b1');

statement ok
merge into t1 as t3 using (select * from t2 ) as t2 on t3.a = t2.a  when not matched  then insert (a,b,c) values(t2.a,t2.b,t2.c);

query TTT
select * from t1 order by a,b,c;
----
1	a1	b1

exclude-from-coverage
statement ok
drop table if exists employees;

exclude-from-coverage
statement ok
drop table if exists salaries;

exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE employees (employee_id INT, employee_name VARCHAR(255),department VARCHAR(255));

exclude-from-coverage
statement ok
drop table if exists salaries;

exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE salaries (employee_id INT,salary DECIMAL(10, 2));

exclude-from-coverage
statement ok
INSERT INTO employees VALUES(1, 'Alice', 'HR'),(2, 'Bob', 'IT'),(3, 'Charlie', 'Finance'),(4, 'David', 'HR');

exclude-from-coverage
statement ok
INSERT INTO salaries VALUES(1, 50000.00),(2, 60000.00);

statement ok
MERGE INTO salaries USING (SELECT * FROM employees) as employees ON salaries.employee_id = employees.employee_id WHEN MATCHED AND employees.department = 'HR' THEN UPDATE SET salaries.salary = salaries.salary + 1000.00 WHEN MATCHED THEN UPDATE SET salaries.salary = salaries.salary + 500.00 WHEN NOT MATCHED THEN INSERT (employee_id, salary) VALUES (employees.employee_id, 55000.00);

query TTT
select * from salaries order by employee_id;
----
1	51000.00
2	60500.00
3	55000.00
4	55000.00

exclude-from-coverage
statement ok
drop table if exists t1_target;

## null cast bug fix
exclude-from-coverage
statement ok
drop table if exists t1_target;

exclude-from-coverage
statement ok
drop table if exists t2_source;

exclude-from-coverage
statement ok
create or replace table t1_target(a int not null);

exclude-from-coverage
statement ok
drop table if exists t2_source;

exclude-from-coverage
statement ok
create or replace table t2_source(a int not null);

exclude-from-coverage
statement ok
insert into t1_target values(1);

exclude-from-coverage
statement ok
insert into t2_source values(1),(2);

statement ok
merge into t1_target using (select * from t2_source) as t2_source on t1_target.a = t2_source.a when matched then update set a = t2_source.a when not matched then insert (a) values(t2_source.a);

query T
select * from t1_target order by a;
----
1
2

exclude-from-coverage
statement ok
drop table if exists cluster_target;

## cluster table test
exclude-from-coverage
statement ok
drop table if exists cluster_target;

exclude-from-coverage
statement ok
drop table if exists cluster_source;

exclude-from-coverage
statement ok
create or replace table cluster_target(a int,b string,c int);

exclude-from-coverage
statement ok
drop table if exists cluster_source;

exclude-from-coverage
statement ok
create or replace table cluster_source(a int,b string,c int);

exclude-from-coverage
statement ok
insert into cluster_source values(12,'b',1),(1,'a',2),(2,'b',3),(2,'a',4),(3,'a',3);

## test update indetify error
#statement error
#merge into cluster_target as t1 using (select * from cluster_source) as t2 on t1.a = t2.a when matched then update set cluster_target.a = t2.a;
#----
#1006

#statement error
#merge into cluster_target as t1 using (select * from cluster_source) as t2 on t1.a = t2.a when matched then update set t2.a = t2.a;
#----
#1006

statement ok
merge into cluster_target as t1 using (select * from cluster_source) as t2 on t1.a = t2.a when not matched then insert (a,b,c) values(t2.a,t2.b,t2.c);

# By default setting, all rows merged from  `cluster_source` will be resident in a single block of `cluster_target`,
# as table `cluster_target` is clustered by `(a,b)`,  the rows inside the one block are assumed to be sorted
# by `(a, b)`,  consequently, the result of the following query should be ordered by `(a,b)` without an explicit
# `order by` clause.
query TTT
select * from cluster_target;
----
1	a	2
2	a	4
2	b	3
3	a	3
12	b	1

## add more tests
exclude-from-coverage
statement ok
drop table if exists target_test;

exclude-from-coverage
statement ok
drop table if exists source_test;

exclude-from-coverage
statement ok
create or replace table target_test(a int,b string);

exclude-from-coverage
statement ok
insert into target_test values(1,'a'),(2,'b'),(3,'c');

exclude-from-coverage
statement ok
create or replace table source_test(a int,b string,delete_flag bool);

exclude-from-coverage
statement ok
insert into source_test values(1,'d',true),(2,'e',true),(3,'f',false),(4,'e',true),(5,'f',false);


exclude-from-coverage
statement ok
drop stage if exists source_parquet_http;

exclude-from-coverage
statement ok
create stage source_parquet_http file_format = (type = parquet);

exclude-from-coverage
statement ok
remove @source_parquet_http;

exclude-from-coverage
statement ok
copy into @source_parquet_http from (select * from source_test);

statement ok
merge into `target_test` as tt using (select `a`,`b`,`delete_flag` from @source_parquet_http (pattern => '.*[.]parquet')) as ss on (ss.`a` = tt.`a`)
when matched and ss.`delete_flag` = true then delete when matched then update set a = ss.a, b = ss.b when not matched and ss.`delete_flag` = false then insert (a,b) values(ss.a,ss.b);

query TT
select * from target_test order by a;
----
3	f
5	f

## test not match cast and predicate index
exclude-from-coverage
statement ok
drop table if exists test_order;

exclude-from-coverage
statement ok
drop table if exists random_source;

exclude-from-coverage
statement ok
create or replace table test_order(id bigint, id1 bigint, id2 bigint, id3 bigint, id4 bigint, id5 bigint, id6 bigint, id7 bigint, s1 varchar, s2 varchar, s3 varchar, s4 varchar, s5 varchar, s6 varchar, s7 varchar, s8 varchar, s9 varchar, s10 varchar, s11 varchar, s12 varchar, s13 varchar, d1 DECIMAL(20, 8), d2 DECIMAL(20, 8), d3 DECIMAL(20, 8), d4 DECIMAL(20, 8), d5 DECIMAL(20, 8), d6 DECIMAL(30, 8), d7 DECIMAL(30, 8), d8 DECIMAL(30, 8), d9 DECIMAL(30, 8), d10 DECIMAL(30, 8),insert_time datetime, insert_time1 datetime, insert_time2 datetime, insert_time3 datetime,i int) ;

exclude-from-coverage
statement ok
create or replace table random_source(id bigint not null, id1 bigint, id2 bigint, id3 bigint, id4 bigint, id5 bigint, id6 bigint, id7 bigint,s1 varchar, s2 varchar, s3 varchar, s4 varchar, s5 varchar, s6 varchar, s7 varchar, s8 varchar, s9 varchar, s10 varchar, s11 varchar, s12 varchar, s13 varchar,d1 DECIMAL(20, 8), d2 DECIMAL(20, 8), d3 DECIMAL(20, 8), d4 DECIMAL(20, 8), d5 DECIMAL(20, 8), d6 DECIMAL(30, 8), d7 DECIMAL(30, 8), d8 DECIMAL(30, 8), d9 DECIMAL(30, 8), d10 DECIMAL(30, 8),insert_time datetime not null, insert_time1 datetime, insert_time2 datetime, insert_time3 datetime,i int);

statement ok
merge into test_order as t using (select id,34 as id1,238 as id2, id3, id4, id5, id6, id7,s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13,d1, d2, d3, d4, d5, d6, d7, d8, d9, d10,insert_time,insert_time1,insert_time2,insert_time3,i from random_source limit 1) as s on t.id = s.id and t.insert_time = s.insert_time when matched then update set id = s.id, id1 = s.id1, id2 = s.id2, id3 = s.id3, id4 = s.id4, id5 = s.id5, id6 = s.id6, id7 = s.id7, s1 = s.s1, s2 = s.s2, s3 = s.s3, s4 = s.s4, s5 = s.s5, s6 = s.s6, s7 = s.s7, s8 = s.s8, s9 = s.s9, s10 = s.s10, s11 = s.s11, s12 = s.s12, s13 = s.s13, d1 = s.d1, d2 = s.d2, d3 = s.d3, d4 = s.d4, d5 = s.d5, d6 = s.d6, d7 = s.d7, d8 = s.d8, d9 = s.d9, d10 = s.d10, insert_time = s.insert_time, insert_time1 = s.insert_time1, insert_time2 = s.insert_time2, insert_time3 = s.insert_time3, i = s.i when not matched then insert (id, id1, id2, id3, id4, id5, id6, id7, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, insert_time, insert_time1, insert_time2, insert_time3, i) values(s.id, s.id1, s.id2, s.id3, s.id4, s.id5, s.id6, s.id7, s.s1, s.s2, s.s3, s.s4, s.s5, s.s6, s.s7, s.s8, s.s9, s.s10, s.s11, s.s12, s.s13, s.d1, s.d2, s.d3, s.d4, s.d5, s.d6, s.d7, s.d8, s.d9, s.d10, s.insert_time, s.insert_time1, s.insert_time2, s.insert_time3, s.i);

## test update list #13297
exclude-from-coverage
statement ok
drop table if exists t11

exclude-from-coverage
statement ok
drop table if exists t12

exclude-from-coverage
statement ok
create or replace table t11(a int,b string, c string);

exclude-from-coverage
statement ok
create or replace table t12(a int,b string, c string);

exclude-from-coverage
statement ok
insert into t11 values(1,'b1','c1'),(2,'b2','c2');

exclude-from-coverage
statement ok
insert into t12 values(1,'b_5','c_5'),(3,'b_6','c_6');

#statement error
#merge into t11 using (select a, c from t12) as t12 on t11.a = t12.a when matched and max(t11.a) > 0 then update set c = t12.c;
#----
#1065

#statement error
#merge into t11 using (select a, c from t12) as t12 on t11.a = t12.a when matched then update set c = count(*);
#----
#1065

## test issue #13287
exclude-from-coverage
statement ok
drop table if exists tt1

exclude-from-coverage
statement ok
create or replace table tt1 (a int, b int);

#statement error
#merge into tt1 using(select 10, 20) as tt2 on tt1.a = 1 when not matched and tt1.b = 2 then insert values (10, 20);
#----
#1065

statement ok
merge into tt1 using(select 10 as a, 20 as b) as tt2 on tt1.a = 1 when not matched and tt2.b = 2 then insert values (10, 20);

query T
select count(*) from tt1;
----
0

## test issue #13367
exclude-from-coverage
statement ok
drop table if exists tt2

exclude-from-coverage
statement ok
create or replace table tt2(a bool, b variant, c map(string, string));

exclude-from-coverage
statement ok
insert into tt2 values (true, '10', {'k1':'v1'}), (false, '20', {'k2':'v2'})

statement ok
merge into tt2 using(select true as x) as t on (x and tt2.a) when matched and tt2.a then update set tt2.b = parse_json('30');

query TTT
select a, b, c from tt2 order by b;
----
0	20	{'k2':'v2'}
1	30	{'k1':'v1'}

## add test: source is table
exclude-from-coverage
statement ok
drop table if exists t1;

exclude-from-coverage
statement ok
drop table if exists t2;

exclude-from-coverage
statement ok
create or replace table t1(a int);

exclude-from-coverage
statement ok
create or replace table t2(a int);

exclude-from-coverage
statement ok
insert into t1 values(1);

exclude-from-coverage
statement ok
insert into t2 values(1),(2);

statement ok
merge into t1 using t2 on t1.a = t2.a when matched then delete when not matched then insert (a) values(t2.a);

query T
select * from t1;
----
2

exclude-from-coverage
statement ok
drop table if exists t1;

exclude-from-coverage
statement ok
drop table if exists t2;

exclude-from-coverage
statement ok
create or replace table t1(b int);

exclude-from-coverage
statement ok
create or replace table t2(a int);

exclude-from-coverage
statement ok
insert into t1 values(1);

exclude-from-coverage
statement ok
insert into t2 values(1),(2);

#statement error
#merge into t1 using t2 on t1.a = t2.a when matched then delete when not matched then insert (a) values(t2.a);
#----
#1065

## add more multi matched statement test
exclude-from-coverage
statement ok
drop table if exists t1;

exclude-from-coverage
statement ok
drop table if exists t2;

exclude-from-coverage
statement ok
create or replace table t1(a int,b string,c bool);

exclude-from-coverage
statement ok
create or replace table t2(a int,b string,c bool);

exclude-from-coverage
statement ok
insert into t1 values(1,'a1',true),(2,'a2',false),(3,'a3',true);

exclude-from-coverage
statement ok
insert into t2 values(1,'b1',true),(2,'b2',false),(3,'b3',true);

exclude-from-coverage
query TTT
select * from t1;
----
1	a1	1
2	a2	0
3	a3	1

exclude-from-coverage
query TTT
select * from t2;
----
1	b1	1
2	b2	0
3	b3	1

statement ok
merge into t1 using t2 on t1.a = t2.a when matched and t1.a = 1 then delete when matched and t1.a = 2 then update * when matched and t1.a = 3 then delete;

query TTT
select * from t1;
----
2	b2	0

statement ok
merge into t1 using t2 on t1.a = t2.a when matched then delete;

query T
select count(*) from t1;
----
0

exclude-from-coverage
statement ok
insert into t1 values(1,'a1',true),(2,'a2',false),(3,'a3',true);

statement ok
merge into t1 using t2 on t1.a = t2.a when matched and t1.a = 2 then update * when matched and t1.a = 1 then delete when matched and t1.a = 3 then update *;

query TTT
select * from t1;
----
2	b2	0
3	b3	1

## issue 13454
exclude-from-coverage
statement ok
drop table if exists tt1;

exclude-from-coverage
statement ok
create or replace table tt1(a bool, b int);

exclude-from-coverage
statement ok
insert into tt1 values (true, 1), (false, 2);

statement ok
merge into tt1 using (select 1 as x) as tt2 on (2 > 1) when matched and a then delete;

query TT
select * from tt1;
----
0	2

## issue #13298
exclude-from-coverage
statement ok
drop table if exists t11;

exclude-from-coverage
statement ok
drop table if exists t12;

exclude-from-coverage
statement ok
create or replace table t12 (a int, b int);

exclude-from-coverage
statement ok
create or replace table t11 (a int, b int);

exclude-from-coverage
statement ok
insert into t11 values (1, 10),(2, 20),(3, 30),(4, 40);

exclude-from-coverage
statement ok
insert into t12 values (1, 10),(2, 20),(3, 30),(4, 40);

statement ok
MERGE INTO t11 USING(SELECT NULL AS c0 FROM t12) AS t12 ON (t11.a OR TRUE) WHEN MATCHED AND TRUE THEN DELETE;

query T
select count(*) from t11;
----
0

## test issue #13732
exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE orders AS SELECT
    number % 5000 AS order_id,
    number % 10000 AS user_id,
    CASE WHEN (rand() * 10)::int % 2 = 0 THEN 'buy'
         ELSE 'sell'
    END AS order_type,
    CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'BTC'
         WHEN (rand() * 10)::int % 3 = 1 THEN 'ETH'
         ELSE 'XRP'
    END AS asset_type,
    (rand() * 100)::decimal(18, 8) AS quantity,
    (rand() * 1000)::decimal(18, 8) AS price,
    CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'completed'
         WHEN (rand() * 10)::int % 3 = 1 THEN 'pending'
         ELSE 'cancelled'
    END AS status,
    date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS created_at,
    date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS updated_at
FROM numbers(5000);

### for now, we disable target_table_optimization for native. Native will
### spilt one block into multi pages. We should fix this one in the future.
statement ok
MERGE INTO orders USING
(
    SELECT
        number % 5000 AS order_id,
        number % 100000 AS user_id,
        CASE WHEN (rand() * 10)::int % 2 = 0 THEN 'buy'
             ELSE 'sell'
        END AS order_type,
        CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'BTC'
             WHEN (rand() * 10)::int % 3 = 1 THEN 'ETH'
             ELSE 'XRP'
        END AS asset_type,
        (rand() * 100)::decimal(18, 8) AS quantity,
        (rand() * 1000)::decimal(18, 8) AS price,
        CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'completed'
             WHEN (rand() * 10)::int % 3 = 1 THEN 'pending'
             ELSE 'cancelled'
        END AS status,
        date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS created_at,
        date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS updated_at
    FROM numbers(5000)
) AS source
ON orders.order_id = source.order_id
WHEN MATCHED THEN
    UPDATE SET
        orders.user_id = source.user_id,
        orders.order_type = source.order_type,
        orders.asset_type = source.asset_type,
        orders.quantity = source.quantity,
        orders.price = source.price,
        orders.status = source.status,
        orders.created_at = source.created_at,
        orders.updated_at = source.updated_at
WHEN NOT MATCHED THEN
    INSERT (order_id, user_id, order_type, asset_type, quantity, price, status, created_at, updated_at)
    VALUES (source.order_id, source.user_id, source.order_type, source.asset_type, source.quantity, source.price, source.status, source.created_at, source.updated_at);

## test issue #13733
exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE transactions AS SELECT
    number % 1000000 AS transaction_id,
    number % 100000 AS user_id,
    CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'deposit'
    WHEN (rand() * 10)::int % 3 = 1 THEN 'withdrawal'
    ELSE 'trade'
END AS transaction_type,
    CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'BTC'
         WHEN (rand() * 10)::int % 3 = 1 THEN 'ETH'
         ELSE 'XRP'
END AS asset_type,
    (rand() * 100)::decimal(18, 8) AS quantity,
    date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS transaction_time
FROM numbers(1000000);

statement ok
MERGE INTO orders AS tt USING
(
    SELECT
        CASE
            WHEN number % 2 = 0 THEN (number / 2) % 250000
            ELSE (SELECT MAX(order_id) FROM orders) + number + 1
        END AS order_id,
        number % 100000 AS user_id,
        CASE WHEN (rand() * 10)::int % 2 = 0 THEN 'buy'
             ELSE 'sell'
        END AS order_type,
        CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'BTC'
             WHEN (rand() * 10)::int % 3 = 1 THEN 'ETH'
             ELSE 'XRP'
        END AS asset_type,
        (rand() * 100)::decimal(18, 8) AS quantity,
        (rand() * 1000)::decimal(18, 8) AS price,
        CASE WHEN (rand() * 10)::int % 3 = 0 THEN 'completed'
             WHEN (rand() * 10)::int % 3 = 1 THEN 'pending'
             ELSE 'cancelled'
        END AS status,
        date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS created_at,
        date_add('day', floor(rand() * 10 % 365)::int, '2021-01-01') AS updated_at,
        CASE WHEN number % 2 = 0 THEN false ELSE true END AS is_delete
    FROM numbers(5000)
) AS ss
ON (tt.user_id = ss.user_id AND tt.asset_type = ss.asset_type)
WHEN MATCHED AND ss.is_delete = true THEN
    DELETE
WHEN MATCHED AND ss.is_delete = false THEN
    UPDATE  * WHEN NOT MATCHED THEN
    INSERT *;

## unsupport complex exprs for now.
## #13798 we need to support non-correlated-subquery for unmatched values exprs
#statement error
#MERGE INTO orders USING (
#    SELECT t.user_id, t.asset_type, 'buy' AS synthetic_order_type, SUM(t.quantity) AS total_quantity, today() AS synthetic_date
#    FROM transactions t
#    WHERE t.transaction_type = 'deposit'
#    GROUP BY t.user_id, t.asset_type
#    HAVING SUM(t.quantity) > 100
#) AS synthetic_orders ON orders.user_id = synthetic_orders.user_id AND orders.asset_type = synthetic_orders.asset_type
#WHEN NOT MATCHED THEN
#    INSERT (order_id, user_id, order_type, asset_type, quantity, price, status, created_at, updated_at)
#    VALUES ((SELECT MAX(order_id) FROM orders) + 1, synthetic_orders.user_id, synthetic_orders.synthetic_order_type, synthetic_orders.asset_type, synthetic_orders.total_quantity, 0, 'pending', synthetic_orders.synthetic_date, synthetic_orders.synthetic_date);
#----
#1065

## issue #13810: rewrite rule test
exclude-from-coverage
statement ok
DROP TABLE IF EXISTS orders;

exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE orders (
                        order_id      INT          NOT NULL,
                        user_id       INT          NOT NULL,
                        order_type    VARCHAR      NOT NULL,
                        asset_type    VARCHAR      NOT NULL,
                        quantity      DECIMAL(18,8) NOT NULL,
                        price         DECIMAL(18,8) NOT NULL,
                        status        VARCHAR      NOT NULL,
                        created_at    DATE         NOT NULL,
                        updated_at    DATE         NOT NULL
);

statement ok
insert into orders values(200007,7,'buy','BTC',4.81412194,48.14121943,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200015,15,'buy','BTC',3.78463552,37.84635523,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200019,19,'buy','BTC',1.61186913,16.11869132,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200031,31,'buy','BTC',3.99013730,39.90137297,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200047,47,'buy','BTC',0.98841829,9.88418289,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200077,77,'buy','BTC',2.07360391,20.73603908,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200087,87,'sell','ETH',9.64567442,96.45674419,'pending',to_date('2021-01-01'),to_date('2021-01-01')),
(200095,95,'buy','BTC',2.26686563,22.66865634,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200098,98,'buy','BTC',1.37252960,13.72529599,'completed',to_date('2021-01-01'),to_date('2021-01-01')),
(200102,102,'buy','BTC',1.53596481,15.35964815,'completed',to_date('2021-01-01'),to_date('2021-01-01'));

statement ok
MERGE INTO orders USING (
    SELECT o.order_id, o.user_id, o.order_type, o.asset_type, o.quantity + a.avg_quantity AS new_quantity, o.price, o.status, o.created_at, o.updated_at
    FROM orders o
             INNER JOIN (
        SELECT user_id, asset_type, sum(quantity) AS avg_quantity
        FROM orders
        GROUP BY user_id, asset_type
    ) a ON o.user_id = a.user_id AND o.asset_type = a.asset_type
) AS joined_data ON orders.order_id = joined_data.order_id
    WHEN MATCHED THEN
        UPDATE SET orders.quantity = joined_data.new_quantity;

query TTTT
SELECT SUM(quantity) AS total_quantity,
       AVG(quantity) AS average_quantity,
       MIN(quantity) AS min_quantity,
       MAX(quantity) AS max_quantity
FROM orders;
----
64.16764110	6.416764110000	1.97683658	19.29134884

exclude-from-coverage
statement ok
create or replace table tb_01 (id int,c1 varchar,c2 datetime(0),c3 json);

exclude-from-coverage
statement ok
create or replace table tmp_01 like tb_01;

exclude-from-coverage
statement ok
insert into tmp_01 values(1,'abc',to_date('2023-11-29'),parse_json('{"a":1}'));

statement ok
merge into  tb_01 as T using ( select * from tmp_01) as S on t.id = s.id when matched then update set id = s.id, c1 = s.c1, c2 = s.c2, c3 = s.c3 when not matched then insert (id, c1, c2, c3) values(s.id, s.c1, s.c2, s.c3);

query TTT
select id,c1,to_date(c2),c3	from tb_01;
----
1	abc	2023-11-29	{"a":1}

## test #issue13932
exclude-from-coverage
statement ok
create or replace table null_target(a int not null,b text);

exclude-from-coverage
statement ok
create or replace table null_source(a int not null,b text);

exclude-from-coverage
statement ok
insert into null_target values(1,'a1');

exclude-from-coverage
statement ok
insert into null_target values(2,'a2');

exclude-from-coverage
statement ok
insert into null_source values(1,'a3');

exclude-from-coverage
statement ok
insert into null_source values(3,'a4');

#statement error
#merge into null_target using null_source on null_target.a = null_source.a when matched then update *
#when not matched then insert (b) values(null_source.b);
#----
#1006

exclude-from-coverage
statement ok
delete from null_source where a = 3;

statement ok
merge into null_target using null_source on null_target.a = null_source.a when matched then update *
when not matched then insert (b) values(null_source.b);

query TT
select * from null_target order by a,b;
----
1	a3
2	a2

## issue#13972
exclude-from-coverage
statement ok
create or replace table tt1_(a bool not null, b int not null, c int not null);

exclude-from-coverage
statement ok
insert into tt1_ values(true, 10, 11),(false, 20, 21);

statement ok
MERGE INTO tt1_ USING
     (SELECT
         657 AS cc0,
         658 AS cc1
     ) AS tRIA7K(cc0, cc1) ON (
         cc0 < cc1)
     WHEN MATCHED AND FALSE THEN UPDATE SET
         a = FALSE,
         b = 332366211
     WHEN MATCHED AND a THEN DELETE
     WHEN NOT MATCHED AND TRUE THEN INSERT (b, c) VALUES(10, 20);

query TTT
select * from tt1_;
----
0	20	21

## issue#14474
exclude-from-coverage
statement ok
create or replace table target_tt1 (a bool not null default true, b int not null default 1);

exclude-from-coverage
statement ok
merge into target_tt1 using(select false, 10) as tt2(a, b) on (target_tt1.b = 1) when not matched then insert (b) values (20);

exclude-from-coverage
query TT
select * from target_tt1;
----
1	20

## test multi insert clauses with specified default values
exclude-from-coverage
statement ok
create or replace table target_default_values(a int default 12,b string default 'yes');

exclude-from-coverage
statement ok
create or replace table source_default_values(a int default 12,b string default 'yes');

exclude-from-coverage
statement ok
insert into target_default_values values(1,'a');

exclude-from-coverage
statement ok
insert into target_default_values values(2,'b');

exclude-from-coverage
statement ok
insert into source_default_values values(1,'c');

exclude-from-coverage
statement ok
insert into source_default_values values(3,'d');

exclude-from-coverage
statement ok
insert into source_default_values values(2,'e');

exclude-from-coverage
statement ok
insert into source_default_values values(4,'f');

statement ok
merge into target_default_values as t1 using source_default_values as t2 on t1.a = t2.a when matched and t1.b = 'a'
then update set t1.b = t2.b when matched then delete when not matched and t2.b = 'd' then insert (a) values(t2.a) when not matched
then insert(b) values(t2.b);

query TT
select * from target_default_values order by a,b;
----
1	c
3	yes
12	f


## test update column only optimization
exclude-from-coverage
statement ok
drop table if exists column_only_optimization_target;

exclude-from-coverage
statement ok
drop table if exists column_only_optimization_source;

exclude-from-coverage
statement ok
create or replace table column_only_optimization_target(a int,b string);

exclude-from-coverage
statement ok
create or replace table column_only_optimization_source(a int,b string);

exclude-from-coverage
statement ok
insert into column_only_optimization_target values(1,'a1'),(2,'a2');

exclude-from-coverage
statement ok
insert into column_only_optimization_target values(3,'a3'),(4,'a4');

exclude-from-coverage
statement ok
insert into column_only_optimization_target values(5,'a5'),(6,'a6');

exclude-from-coverage
statement ok
insert into column_only_optimization_target values(7,'a7'),(8,'a8');

exclude-from-coverage
query TT
select * from column_only_optimization_target order by a,b;
----
1	a1
2	a2
3	a3
4	a4
5	a5
6	a6
7	a7
8	a8

exclude-from-coverage
statement ok
insert into column_only_optimization_source values(1,'b1'),(2,'b2');

exclude-from-coverage
statement ok
insert into column_only_optimization_source values(3,'b3'),(4,'b4');

exclude-from-coverage
query TT
select * from column_only_optimization_source order by a,b;
----
1	b1
2	b2
3	b3
4	b4

statement ok
merge into column_only_optimization_target as t1 using column_only_optimization_source as t2 on
t1.a = t2.a when matched then update set t1.b = t2.b when not matched then insert (a,b) values (t2.a, t2.b);

query TT
select * from column_only_optimization_target order by a,b;
----
1	b1
2	b2
3	b3
4	b4
5	a5
6	a6
7	a7
8	a8

## add more tests cases for distributed modes.
exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE IF NOT EXISTS lineitem_target_origin_200_blocks1 (
    l_orderkey BIGINT not null,
    l_partkey BIGINT not null,
    l_suppkey BIGINT not null,
    l_linenumber BIGINT not null,
    l_quantity DECIMAL(15, 2) not null,
    l_extendedprice DECIMAL(15, 2) not null,
    l_discount DECIMAL(15, 2) not null,
    l_tax DECIMAL(15, 2) not null,
    l_returnflag STRING not null,
    l_linestatus STRING not null,
    l_shipdate DATE not null,
    l_commitdate DATE not null,
    l_receiptdate DATE not null,
    l_shipinstruct STRING not null,
    l_shipmode STRING not null,
    l_comment STRING not null
);

exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE IF NOT EXISTS lineitem_target_origin_400_blocks1 (
    l_orderkey BIGINT not null,
    l_partkey BIGINT not null,
    l_suppkey BIGINT not null,
    l_linenumber BIGINT not null,
    l_quantity DECIMAL(15, 2) not null,
    l_extendedprice DECIMAL(15, 2) not null,
    l_discount DECIMAL(15, 2) not null,
    l_tax DECIMAL(15, 2) not null,
    l_returnflag STRING not null,
    l_linestatus STRING not null,
    l_shipdate DATE not null,
    l_commitdate DATE not null,
    l_receiptdate DATE not null,
    l_shipinstruct STRING not null,
    l_shipmode STRING not null,
    l_comment STRING not null
);

exclude-from-coverage
statement ok
CREATE OR REPLACE TABLE IF NOT EXISTS lineitem_random(
    l_orderkey BIGINT not null,
    l_partkey BIGINT not null,
    l_suppkey BIGINT not null,
    l_linenumber BIGINT not null,
    l_quantity DECIMAL(15, 2) not null,
    l_extendedprice DECIMAL(15, 2) not null,
    l_discount DECIMAL(15, 2) not null,
    l_tax DECIMAL(15, 2) not null,
    l_returnflag STRING not null,
    l_linestatus STRING not null,
    l_shipdate DATE not null,
    l_commitdate DATE not null,
    l_receiptdate DATE not null,
    l_shipinstruct STRING not null,
    l_shipmode STRING not null,
    l_comment STRING not null
);

## add 4w rows
exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

exclude-from-coverage
statement ok
insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;

##exclude-from-coverage
##query T
##select count(*) from lineitem_target_origin_400_blocks1;
##----
##40000
##
##exclude-from-coverage
##statement ok
##insert into lineitem_target_origin_200_blocks1 select * from lineitem_target_origin_400_blocks1;
##
##exclude-from-coverage
##query T
##select count(*) from lineitem_target_origin_200_blocks1;
##----
##40000
##
##exclude-from-coverage
##statement ok
##insert into lineitem_target_origin_400_blocks1 select * from lineitem_random limit 5000;
##
##exclude-from-coverage
##query T
##select count(*) from lineitem_target_origin_400_blocks1;
##----
##45000

## it maybe flaky test, but in most times, it's normal.
##statement ok
##MERGE INTO lineitem_target_origin_400_blocks1 as t1 using lineitem_target_origin_200_blocks1 as t2 on
##t1.l_orderkey = t2.l_orderkey and
##t1.l_partkey = t2.l_partkey
##and t1.l_suppkey = t2.l_suppkey and
##t1.l_linenumber = t2.l_linenumber and
##t1.l_quantity = t2.l_quantity and
##t1.l_extendedprice = t2.l_extendedprice and
##t1.l_discount = t2.l_discount
##when matched then update *
##when not matched then insert *;
