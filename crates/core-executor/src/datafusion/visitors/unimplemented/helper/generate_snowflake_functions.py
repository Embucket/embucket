#!/usr/bin/env python3

import csv
import re
from collections import defaultdict
from pathlib import Path

def normalize_category_name(category: str) -> str:
    """Convert category name to a valid Rust const identifier"""
    # Remove special characters and normalize
    normalized = re.sub(r'[^\w\s]', '', category)
    # Replace spaces and convert to UPPER_SNAKE_CASE
    normalized = re.sub(r'\s+', '_', normalized.strip())
    return normalized.upper()

def escape_rust_string(s: str) -> str:
    """Escape special characters for Rust string literals"""
    if not s:
        return '""'
    # Escape backslashes and quotes
    escaped = s.replace('\\', '\\\\').replace('"', '\\"')
    return f'"{escaped}"'

def generate_rust_file(functions_by_category: dict, output_file: str):
    """Generate the Rust file with const arrays"""
    
    content = []
    content.append("// This file is auto-generated by generate_snowflake_functions.py")
    content.append("// Do not edit manually!")
    content.append("")
    content.append("use super::FunctionInfo;")
    content.append("")
    
    # Generate const arrays for each category
    for category, functions in sorted(functions_by_category.items()):
        const_name = f"{normalize_category_name(category)}_FUNCTIONS"
        content.append(f"pub const {const_name}: &[(&str, FunctionInfo)] = &[")
        
        for func in sorted(functions, key=lambda x: x['name']):
            name = func['name']
            description = func['description']
            docs_url = func.get('docs_url', '')
            subcategory = func.get('subcategory', '')
            
            content.append(f"    ({escape_rust_string(name)}, FunctionInfo::new(")
            content.append(f"        {escape_rust_string(name)},")
            content.append(f"        {escape_rust_string(description)}")
            content.append("    )")
            
            if docs_url:
                content.append(f"    .with_docs({escape_rust_string(docs_url)})")
            
            if subcategory:
                content.append(f"    .with_subcategory({escape_rust_string(subcategory)})")
            
            content.append("    ),")
        
        content.append("];")
        content.append("")
     
       
    # Write to file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(content))

def main():
    csv_file = "Snowflake Iceberg Tables Compatibility Project - BuiltInFunctions Snowflake.csv"
    output_file = "../generated_snowflake_functions.rs"
    
    # Check if CSV file exists
    if not Path(csv_file).exists():
        print(f"Error: CSV file '{csv_file}' not found!")
        return
    
    functions_by_category = defaultdict(list)
    
    with open(csv_file, 'r', encoding='utf-8') as f:
        reader = csv.reader(f)
        
        # Get headers
        headers = next(reader)
        print(f"CSV headers: {headers}")
        
        # Find column indices based on actual CSV structure:
        # A, <description>, <snowflake_docs_section>, <mapping_info>, Proposed category, Subcategory(If applied), PureURL
        try:
            name_col = 0  # Column A (function name)
            description_col = 1  # Second column (description)
            # Skip column 2 (Snowflake docs section) - we don't use this for categorization
            # Skip column 3 (mapping info)
            category_col = headers.index('Proposed category')  # Column 4 - this is what we want for categorization
            subcategory_col = headers.index('Subcategory(If applied)')  # Column 5
            docs_col = headers.index('PureURL')  # Column 6
            
            print(f"Using columns: name={name_col}, description={description_col}, category={category_col}, subcategory={subcategory_col}, docs={docs_col}")
            
        except ValueError as e:
            print(f"Error finding columns: {e}")
            print(f"Available headers: {headers}")
            return
        
        # Process each row
        for row_num, row in enumerate(reader, start=2):  # Start at 2 since we skip header
            # Skip empty rows or rows that are too short
            if not row or len(row) <= max(name_col, description_col, category_col, docs_col):
                continue
            
            name = row[name_col].strip() if len(row) > name_col else ''
            description = row[description_col].strip() if len(row) > description_col else ''
            category = row[category_col].strip() if len(row) > category_col else ''
            subcategory = row[subcategory_col].strip() if len(row) > subcategory_col else ''
            docs_url = row[docs_col].strip() if len(row) > docs_col else ''
            
            # Skip empty rows or header separators (A, B, C, D, E)
            if not name or name in ['A', 'B', 'C', 'D', 'E'] or not category:
                continue
            
            # Use the proposed category directly (values like "numeric", "aggregate", etc.)
            primary_category = category.strip()
            
            function_info = {
                'name': name,
                'description': description,
                'subcategory': subcategory if subcategory else None,
                'docs_url': docs_url if docs_url else None
            }
            
            functions_by_category[primary_category].append(function_info)
            
            # Debug: print first few entries to verify
            if row_num <= 5:
                print(f"Row {row_num}: {name} -> category: '{primary_category}', subcategory: '{subcategory}'")
    
    if not functions_by_category:
        print("Error: No functions found in CSV file!")
        return
    
    print(f"\nFound {sum(len(funcs) for funcs in functions_by_category.values())} functions in {len(functions_by_category)} categories:")
    for category, funcs in sorted(functions_by_category.items()):
        print(f"  {category}: {len(funcs)} functions")
    
    # Generate the Rust file
    generate_rust_file(functions_by_category, output_file)
    print(f"\nGenerated Rust file: {output_file}")

if __name__ == "__main__":
    main() 