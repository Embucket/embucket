/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * UI Router API
 * Defines the specification for the UI Catalog API
 * OpenAPI spec version: 1.0.2
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { useAxiosMutator } from '../lib/axiosMutator';
import type { ErrorType } from '../lib/axiosMutator';
import type {
  ErrorResponse,
  GetTablePreviewDataParams,
  TableColumnsResponse,
  TablePreviewDataResponse,
  TableStatisticsResponse,
  TableUploadPayload,
  TableUploadResponse,
  UploadFileParams,
} from './models';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getTableColumns = (
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: SecondParameter<typeof useAxiosMutator>,
  signal?: AbortSignal,
) => {
  return useAxiosMutator<TableColumnsResponse>(
    {
      url: `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/columns`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetTableColumnsQueryKey = (
  databaseName: string,
  schemaName: string,
  tableName: string,
) => {
  return [
    `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/columns`,
  ] as const;
};

export const getGetTableColumnsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTableColumns>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTableColumnsQueryKey(databaseName, schemaName, tableName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTableColumns>>> = ({ signal }) =>
    getTableColumns(databaseName, schemaName, tableName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(databaseName && schemaName && tableName),
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTableColumnsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTableColumns>>
>;
export type GetTableColumnsInfiniteQueryError = ErrorType<ErrorResponse>;

export function useGetTableColumnsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableColumns>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableColumns>>,
          TError,
          Awaited<ReturnType<typeof getTableColumns>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableColumnsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableColumns>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableColumns>>,
          TError,
          Awaited<ReturnType<typeof getTableColumns>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableColumnsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableColumns>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTableColumnsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableColumns>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTableColumnsInfiniteQueryOptions(
    databaseName,
    schemaName,
    tableName,
    options,
  );

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTableColumnsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTableColumns>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>>;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTableColumnsQueryKey(databaseName, schemaName, tableName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTableColumns>>> = ({ signal }) =>
    getTableColumns(databaseName, schemaName, tableName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(databaseName && schemaName && tableName),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTableColumnsQueryResult = NonNullable<Awaited<ReturnType<typeof getTableColumns>>>;
export type GetTableColumnsQueryError = ErrorType<ErrorResponse>;

export function useGetTableColumns<
  TData = Awaited<ReturnType<typeof getTableColumns>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableColumns>>,
          TError,
          Awaited<ReturnType<typeof getTableColumns>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableColumns<
  TData = Awaited<ReturnType<typeof getTableColumns>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableColumns>>,
          TError,
          Awaited<ReturnType<typeof getTableColumns>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableColumns<
  TData = Awaited<ReturnType<typeof getTableColumns>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>>;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTableColumns<
  TData = Awaited<ReturnType<typeof getTableColumns>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableColumns>>, TError, TData>>;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTableColumnsQueryOptions(databaseName, schemaName, tableName, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTablePreviewData = (
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: SecondParameter<typeof useAxiosMutator>,
  signal?: AbortSignal,
) => {
  return useAxiosMutator<TablePreviewDataResponse>(
    {
      url: `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/rows`,
      method: 'GET',
      params,
      signal,
    },
    options,
  );
};

export const getGetTablePreviewDataQueryKey = (
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
) => {
  return [
    `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/rows`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetTablePreviewDataInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTablePreviewData>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTablePreviewDataQueryKey(databaseName, schemaName, tableName, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTablePreviewData>>> = ({ signal }) =>
    getTablePreviewData(databaseName, schemaName, tableName, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(databaseName && schemaName && tableName),
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTablePreviewDataInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTablePreviewData>>
>;
export type GetTablePreviewDataInfiniteQueryError = ErrorType<ErrorResponse>;

export function useGetTablePreviewDataInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTablePreviewData>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params: undefined | GetTablePreviewDataParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTablePreviewData>>,
          TError,
          Awaited<ReturnType<typeof getTablePreviewData>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTablePreviewDataInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTablePreviewData>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTablePreviewData>>,
          TError,
          Awaited<ReturnType<typeof getTablePreviewData>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTablePreviewDataInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTablePreviewData>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTablePreviewDataInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTablePreviewData>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTablePreviewDataInfiniteQueryOptions(
    databaseName,
    schemaName,
    tableName,
    params,
    options,
  );

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTablePreviewDataQueryOptions = <
  TData = Awaited<ReturnType<typeof getTablePreviewData>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetTablePreviewDataQueryKey(databaseName, schemaName, tableName, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTablePreviewData>>> = ({ signal }) =>
    getTablePreviewData(databaseName, schemaName, tableName, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(databaseName && schemaName && tableName),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTablePreviewDataQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTablePreviewData>>
>;
export type GetTablePreviewDataQueryError = ErrorType<ErrorResponse>;

export function useGetTablePreviewData<
  TData = Awaited<ReturnType<typeof getTablePreviewData>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params: undefined | GetTablePreviewDataParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTablePreviewData>>,
          TError,
          Awaited<ReturnType<typeof getTablePreviewData>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTablePreviewData<
  TData = Awaited<ReturnType<typeof getTablePreviewData>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTablePreviewData>>,
          TError,
          Awaited<ReturnType<typeof getTablePreviewData>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTablePreviewData<
  TData = Awaited<ReturnType<typeof getTablePreviewData>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTablePreviewData<
  TData = Awaited<ReturnType<typeof getTablePreviewData>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  params?: GetTablePreviewDataParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTablePreviewData>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTablePreviewDataQueryOptions(
    databaseName,
    schemaName,
    tableName,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const uploadFile = (
  databaseName: string,
  schemaName: string,
  tableName: string,
  tableUploadPayload: TableUploadPayload,
  params?: UploadFileParams,
  options?: SecondParameter<typeof useAxiosMutator>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`uploadFile`, tableUploadPayload.uploadFile);

  return useAxiosMutator<TableUploadResponse>(
    {
      url: `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/rows`,
      method: 'POST',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
      params,
      signal,
    },
    options,
  );
};

export const getUploadFileMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    {
      databaseName: string;
      schemaName: string;
      tableName: string;
      data: TableUploadPayload;
      params?: UploadFileParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof useAxiosMutator>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadFile>>,
  TError,
  {
    databaseName: string;
    schemaName: string;
    tableName: string;
    data: TableUploadPayload;
    params?: UploadFileParams;
  },
  TContext
> => {
  const mutationKey = ['uploadFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFile>>,
    {
      databaseName: string;
      schemaName: string;
      tableName: string;
      data: TableUploadPayload;
      params?: UploadFileParams;
    }
  > = (props) => {
    const { databaseName, schemaName, tableName, data, params } = props ?? {};

    return uploadFile(databaseName, schemaName, tableName, data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFile>>>;
export type UploadFileMutationBody = TableUploadPayload;
export type UploadFileMutationError = ErrorType<ErrorResponse>;

export const useUploadFile = <TError = ErrorType<ErrorResponse>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadFile>>,
      TError,
      {
        databaseName: string;
        schemaName: string;
        tableName: string;
        data: TableUploadPayload;
        params?: UploadFileParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadFile>>,
  TError,
  {
    databaseName: string;
    schemaName: string;
    tableName: string;
    data: TableUploadPayload;
    params?: UploadFileParams;
  },
  TContext
> => {
  const mutationOptions = getUploadFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getTableStatistics = (
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: SecondParameter<typeof useAxiosMutator>,
  signal?: AbortSignal,
) => {
  return useAxiosMutator<TableStatisticsResponse>(
    {
      url: `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/statistics`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetTableStatisticsQueryKey = (
  databaseName: string,
  schemaName: string,
  tableName: string,
) => {
  return [
    `/ui/databases/${databaseName}/schemas/${schemaName}/tables/${tableName}/statistics`,
  ] as const;
};

export const getGetTableStatisticsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTableStatistics>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTableStatisticsQueryKey(databaseName, schemaName, tableName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTableStatistics>>> = ({ signal }) =>
    getTableStatistics(databaseName, schemaName, tableName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(databaseName && schemaName && tableName),
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTableStatisticsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTableStatistics>>
>;
export type GetTableStatisticsInfiniteQueryError = ErrorType<ErrorResponse>;

export function useGetTableStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableStatistics>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableStatistics>>,
          TError,
          Awaited<ReturnType<typeof getTableStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableStatistics>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableStatistics>>,
          TError,
          Awaited<ReturnType<typeof getTableStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableStatistics>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTableStatisticsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTableStatistics>>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>
    >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTableStatisticsInfiniteQueryOptions(
    databaseName,
    schemaName,
    tableName,
    options,
  );

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTableStatisticsQueryOptions = <
  TData = Awaited<ReturnType<typeof getTableStatistics>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>>;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTableStatisticsQueryKey(databaseName, schemaName, tableName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTableStatistics>>> = ({ signal }) =>
    getTableStatistics(databaseName, schemaName, tableName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(databaseName && schemaName && tableName),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTableStatisticsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTableStatistics>>
>;
export type GetTableStatisticsQueryError = ErrorType<ErrorResponse>;

export function useGetTableStatistics<
  TData = Awaited<ReturnType<typeof getTableStatistics>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableStatistics>>,
          TError,
          Awaited<ReturnType<typeof getTableStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableStatistics<
  TData = Awaited<ReturnType<typeof getTableStatistics>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTableStatistics>>,
          TError,
          Awaited<ReturnType<typeof getTableStatistics>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTableStatistics<
  TData = Awaited<ReturnType<typeof getTableStatistics>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>>;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTableStatistics<
  TData = Awaited<ReturnType<typeof getTableStatistics>>,
  TError = ErrorType<ErrorResponse>,
>(
  databaseName: string,
  schemaName: string,
  tableName: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTableStatistics>>, TError, TData>>;
    request?: SecondParameter<typeof useAxiosMutator>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTableStatisticsQueryOptions(
    databaseName,
    schemaName,
    tableName,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
