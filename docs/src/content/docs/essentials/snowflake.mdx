---
title: Snowflake compatibility
description: Details on how Embucket implements Snowflake compatibility, current limitations and future plans.
---

import { Aside, Steps } from '@astrojs/starlight/components';

Embucket provides Snowflake compatibility through SQL dialect support and API compatibility. This document explains how Embucket implements Snowflake compatibility, covers current limitations, and outlines development plans.

This document doesn't cover Snowflake enterprise features, data governance capabilities, or advanced security configurations. The current focus remains on core SQL compatibility and API integration for analytical workloads.

Embucket supports the Snowflake SQL dialect and provides a Snowflake v1 REST API. You can use existing Snowflake clients and tools with Embucket.

**Key compatibility features:**

- Snowflake v1 REST API compatibility
- SQL dialect support through [Apache DataFusion](https://datafusion.apache.org/) engine
- Compatible with snowflake-connector-python and dependent tools
- Integration with [dbt](https://docs.getdbt.com/), snowflake-cli, and Apache Superset

## API compatibility

Embucket provides a Snowflake v1 REST API that works with any Snowflake client. The platform has tested compatibility primarily with snowflake-connector-python and tools that depend on it, including [dbt](https://docs.getdbt.com/), snowflake-cli, and Apache Superset.

{/* vale Google.Headings = NO */}

## SQL engine compatibility

{/* vale Google.Headings = YES */}

Embucket provides a SQL engine based on **[Apache DataFusion](https://datafusion.apache.org/)** - an [Apache Arrow](https://arrow.apache.org/)-native query engine. The engine works with any SQL client. Embucket aims for 100% SQL dialect compatibility with Snowflake but currently support a subset of SQL features. Embucket includes some built-in functions and data types that Snowflake doesn't provide.

## Compatibility testing

Embucket verifies compatibility using two test methods:

- **SQL Logic Tests**: Verify SQL engine compatibility with Snowflake
- **[dbt](https://docs.getdbt.com/) integration tests**: Verify REST API compatibility with Snowflake

Embucket uses the [dbt](https://docs.getdbt.com/) Gitlab project as a compatibility benchmark. The Embucket [repository](https://github.com/Embucket/embucket) displays current compatibility badges for both SQL logic test suite and dbt Gitlab.

## Architecture differences

Snowflake provides a managed analytics database built on [FoundationDB](https://www.foundationdb.org) and object storage such as S3. Snowflake delivers a managed service for deploying and scaling analytics workloads. See their [whitepaper](https://www.cs.cmu.edu/~15721-f24/papers/Snowflake.pdf) for details.

Embucket provides an open source Snowflake alternative with the same ease of use and manageability. You gain open source and self-hosting benefits. The system uses open technologies including [Apache DataFusion](https://datafusion.apache.org/), [Apache Iceberg](https://iceberg.apache.org/), [SlateDB](https://slatedb.io/), [Apache Arrow](https://arrow.apache.org/), and Parquet.

These technology choices differ structurally:

- **Metadata storage**: [SlateDB](https://slatedb.io/) on object storage instead of FoundationDB distributed database
- **Data format**: [Iceberg](https://iceberg.apache.org/) and Parquet format instead of proprietary format
- **Query execution**: Single-node [DataFusion](https://datafusion.apache.org/) SQL engine with [Arrow](https://arrow.apache.org/) in-memory representation

<Aside type="caution">
  Some features remain unsupported due to limitations in Embucket's dependencies and architecture.
</Aside>

## Current limitations

### Architecture constraints

- **Single-node execution**: Query processing limits to one node's memory and CPU capacity
- **No distributed parallelism**: Can't distribute queries across many nodes
- **Single writer**: Only one instance can write to a table simultaneously

### Data type limitations

- **Limited VARIANT support**: Embucket stores VARIANT as JSON-serialized `TEXT` because Parquet, Iceberg, and Arrow don't support VARIANT natively
- **Numeric type differences**: Embucket uses different numeric types than Snowflake for type coercion
- **Timestamp precision**: Fixed nanosecond precision differs from Snowflake's variable precision
- **No collation/charset support**: All text data uses UTF-8 encoding. Locale-aware collations and custom character sets remain unsupported for some time.

### Error handling

- **Different error format**: Error messages don't match Snowflake's format

## VARIANT data type support

Embucket implements VARIANT as JSON-serialized `TEXT` on the storage layer. This approach becomes necessary because Parquet, Iceberg, and Arrow don't support VARIANT natively.

<Steps>

1. **Create a table**

   ```sql
   create table t2 (c1 variant) as values (parse_json('{"k1":1}'));
   ```

   ```
   +-------+
   | count |
   |-------|
   | 1     |
   +-------+
   ```

2. **Count rows**

   ```sql
   select * from t2;
   ```

   ```
   +----------+
   | c1       |
   |----------|
   | {"k1":1} |
   +----------+
   ```

</Steps>

### Storage implementation details

In the storage layer, Embucket stores VARIANT as JSON-serialized `TEXT`.

```sql
select arrow_typeof(c1) from t2;
```

```
+-------------------------------------+
| arrow_typeof(embucket.public.t2.c1) |
|-------------------------------------|
| Utf8                                |
+-------------------------------------+
```

## Numeric type handling

Embucket uses [DataFusion](https://datafusion.apache.org/) for type coercion and may use different numeric types than Snowflake. This produces different results in some cases.

For aggregation functions on numeric types, Snowflake uses Decimal with dynamic precision and scale. Embucket uses Decimal128 for better compatibility and fewer errors. `Decimal128` provides the closest behavior to Snowflake's `NUMBER` type.

<Aside type="note">This feature remains under development.</Aside>

### Numeric function result differences

**Embucket result:**

```sql
select avg(a), system$typeof(avg(a)) from values (1.0), (2.0), (10.0) as t(a);
```

```
+--------------------------------------------+
| avg(t.a)          | arrow_typeof(avg(t.a)) |
|-------------------+------------------------|
| 4.333333333333333 | Decimal128(7,5)        |
+--------------------------------------------+
```

**Snowflake result:**

```sql
select avg(a), system$typeof(avg(a)) from values (1.0), (2.0), (10.0) as t(a);
```

```
+----------------------------------+
| AVG(A)   | SYSTEM$TYPEOF(AVG(A)) |
|----------+-----------------------|
| 4.333333 | NUMBER(20,6)[SB16]    |
+----------------------------------+
```

## Timestamp handling

Embucket uses [Arrow](https://arrow.apache.org/)'s timestamp type: a 64-bit integer representing nanoseconds since the Unix epoch (1970-01-01 00:00:00 UTC). This fixed precision type always uses nanoseconds. Snowflake uses different precision.

### Timezone storage differences

- **Snowflake**: Stores timezone offset per timestamp value
- **Embucket**: Stores timezone offset per column

Embucket may return different results for the same query depending on the session timezone setting.

## Error message format

Embucket returns errors in a different format than Snowflake. [Apache Arrow](https://arrow.apache.org/) and [DataFusion](https://datafusion.apache.org/) generate these errors and they don't match Snowflake's error format.

## Development roadmap

The development roadmap includes these compatibility improvements:

- **Numeric support**: Add dynamic precision Decimal types for aggregation functions
- **VARIANT support**: Add native VARIANT storage when underlying dependencies support it
- **Timestamp support**: Improve timezone handling to match Snowflake's per-value storage
- **Error format**: Align error messages with Snowflake's error format
